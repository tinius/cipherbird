// Generated by CoffeeScript 1.10.0
var ctdServices,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ctdServices = angular.module('ctdServices', []);

ctdServices.factory('twitterService', function($q) {
  return {
    twitter: null,
    user: null,
    contacts: null,
    messages: null,
    initialise: function() {
      var twitter;
      OAuth.initialize('r-DeHkzLRBjMi-olR_oWEwD3c3E');
      return twitter = OAuth.create('twitter');
    },
    twitterReady: function() {
      return this.twitter;
    },
    disconnectTwitter: function() {
      OAuth.clearCache('twitter');
      return this.twitter = null;
    },
    connectToTwitter: function() {
      var deferred, self;
      self = this;
      deferred = $q.defer();
      OAuth.popup('twitter', function(error, result) {
        if (!error) {
          self.twitter = result;
          self.twitter.get('/1.1/account/verify_credentials.json').done(function(resp) {
            return self.user = resp.screen_name;
          });
          return deferred.resolve();
        } else {
          return console.log(error);
        }
      });
      return deferred.promise;
    },
    filterContacts: function(ids) {
      var count, deferred, promise;
      count = 0;
      deferred = $q.defer();
      promise = this.twitter.get('/1.1/friendships/lookup.json?user_id=' + ids.join()).done(function(data) {
        var users;
        users = data.filter(function(user) {
          return indexOf.call(user.connections, 'following') >= 0 && indexOf.call(user.connections, 'followed_by') >= 0;
        }).map(function(user) {
          user.screenName = user.screen_name;
          user.nameLower = user.name.toLowerCase();
          user.screenNameLower = user.screenName.toLowerCase();
          return user;
        });
        return deferred.resolve(users);
      });
      return deferred.promise;
    },
    getContacts: function() {
      var deferred, promise, self;
      self = this;
      deferred = $q.defer();
      if (self.contactList) {
        deferred.resolve(self.contactList);
      } else {
        promise = self.twitter.get('/1.1/friends/ids.json?user_id=me&cursor=-1').done(function(data) {
          self.contactList = self.filterContacts(data.ids);
          return deferred.resolve(self.contactList);
        });
      }
      return deferred.promise;
    },
    postMessage: function(recipient, message) {
      var deferred, promise;
      deferred = $q.defer();
      promise = this.twitter.post('/1.1/direct_messages/new.json', {
        data: {
          user_id: recipient,
          text: message
        }
      }).done(function(data) {
        return deferred.resolve(data);
      });
      return deferred.promise;
    },
    getMessages: function(since_id) {
      var deferred, promise, self;
      if (since_id == null) {
        since_id = -1;
      }
      self = this;
      deferred = $q.defer();
      promise = self.twitter.get('/1.1/direct_messages.json?count=8&full_text=true&since_id=' + since_id).done(function(data) {
        return deferred.resolve(data);
      });
      return deferred.promise;
    }
  };
});

ctdServices.factory('cryptoService', function() {
  return {
    isEncrypted: function(message) {
      var bits, error, error1, salt;
      try {
        salt = message.split('\n')[0];
        bits = sjcl.codec.base64.toBits(salt);
        if (bits.length === 2) {
          return true;
        }
      } catch (error1) {
        error = error1;
      }
      return false;
    },
    decryptMessage: function(password, message) {
      var ciphertext, dh, iv, messageLines, plain, salt;
      messageLines = message.split('\n');
      salt = messageLines[0];
      iv = messageLines[1];
      ciphertext = messageLines[2];
      dh = {
        v: 1,
        ts: 64,
        ks: 128,
        mode: 'ccm',
        adata: '',
        rp: '',
        iter: 1000
      };
      dh.iv = iv;
      dh.salt = salt;
      dh.ct = ciphertext;
      plain = sjcl.decrypt(password, JSON.stringify(dh));
      return plain;
    },
    encryptMessage: function(password, message) {
      var ciphertext, encryptionResult, iv, salt;
      encryptionResult = JSON.parse(sjcl.encrypt(password, message));
      ciphertext = encryptionResult.ct;
      salt = encryptionResult.salt;
      iv = encryptionResult.iv;
      return salt + "\n" + iv + "\n" + ciphertext;
    }
  };
});

ctdServices.factory('googleService', function($q, $http) {
  var self;
  self = this;
  self.googleClientId = '594888625113-rmave0jlk2aku3ftb8caaf7mba12kc3e.apps.googleusercontent.com';
  self.googleApiKey = 'AIzaSyDRyeAZPLvaAFiQW-0Gct-9oSyLQztiJtM';
  self.scopes = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/userinfo.email'];
  self.user = null;
  self.googleReady = function() {
    return self.user;
  };
  self.listFiles = function() {
    var req;
    req = gapi.client.drive.files.list();
    return req.execute(function(resp) {
      var files;
      return files = resp.items;
    });
  };
  self.getUser = function() {
    var accessToken;
    if (!self.user) {
      accessToken = gapi.auth.getToken().access_token;
      $http({
        method: 'GET',
        url: 'https://www.googleapis.com/oauth2/v1/userinfo?alt=json',
        headers: {
          'Authorization': 'Bearer ' + accessToken
        }
      }).then(function(resp) {
        if (resp.data.email) {
          return self.user = resp.data.email;
        }
      });
    }
    return self.user;
  };
  self.tryDownload = function(url) {
    var deferred, promise;
    deferred = $q.defer();
    promise = $http.get(url).then(function(resp) {
      return deferred.resolve(resp);
    });
    return deferred.promise;
  };
  self.downloadFile = function(url) {
    var deferred, promise;
    deferred = $q.defer();
    promise = $http.get('https://crossorigin.me/' + url).then(function(resp) {
      return deferred.resolve(resp.data);
    });
    return deferred.promise;
  };
  self.makePublic = function(id, url) {
    var body, deferred, req;
    deferred = $q.defer();
    body = {
      value: '',
      type: 'anyone',
      role: 'reader'
    };
    req = gapi.client.drive.permissions.insert({
      fileId: id,
      resource: body
    });
    req.execute(function(response) {
      return deferred.resolve(url);
    });
    return deferred.promise;
  };
  self.uploadImage = function(image) {
    var body, boundary, closeDelimiter, deferred, delimiter, metadata, request;
    deferred = $q.defer();
    boundary = '-----1337';
    delimiter = '\r\n--' + boundary + '\r\n';
    closeDelimiter = '\r\n--' + boundary + '--';
    metadata = {
      mimeType: 'text/plain',
      title: 'aaa_text'
    };
    body = delimiter + 'Content-Type: application/json\r\n\r\n' + JSON.stringify(metadata) + delimiter + 'Content-Type: text/plain\r\n' + 'Content-Transfer-Encoding: 8bit\r\n\r\n' + image + closeDelimiter;
    request = gapi.client.request({
      path: '/upload/drive/v2/files',
      method: 'POST',
      params: {
        uploadType: 'multipart'
      },
      headers: {
        'Content-Type': 'multipart/mixed, boundary="' + boundary + '"'
      },
      body: body
    });
    request.execute(function(file) {
      return deferred.resolve(self.makePublic(file.id, file.webContentLink));
    });
    return deferred.promise;
  };
  self.loadClient = function() {
    return gapi.client.load('drive', 'v2', self.getUser);
  };
  self.initialise = function(authResult) {
    if (authResult && !authResult.error) {
      return self.loadClient();
    } else {
      return gapi.auth.authorize({
        client_id: self.googleClientId,
        scope: self.scopes,
        immediate: false
      }, self.initialise);
    }
  };
  self.getAccessToken = function() {
    return gapi.auth.authorize({
      client_id: self.googleClientId,
      scope: self.scopes,
      immediate: true
    }, self.initialise);
  };
  return this;
});
